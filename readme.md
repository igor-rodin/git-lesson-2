# **Система контроля версий**

**Cистема контроля версий (VCS)** — программное обеспечение для облегчения работы с изменяющейся информацией.

- **_Полная история изменений каждого файла за длительный период_**. Это касается всех изменений, внесенных огромным количеством людей за долгие годы. Изменением считается создание и удаление файлов, а также редактирование их содержимого. Различные инструменты VCS отличаются тем, насколько хорошо они обрабатывают операции переименования и перемещения файлов. В историю также должны входить сведения об авторе, дата и комментарий с описанием цели каждого изменения. Наличие полной истории позволяет возвращаться к предыдущим версиям, чтобы проводить анализ основных причин возникновения ошибок и устранять проблемы в старых версиях программного обеспечения.

* **_Ветвление и слияние_**. Создание «веток» позволяет иметь несколько независимых друг от друга направлений разработки, а также выполнять их слияние, чтобы разработчики могли проверить, что изменения, внесенные в каждую из веток, не конфликтуют друг с другом. Многие команды разработчиков программного обеспечения создают отдельные ветки для каждой функциональной возможности, для каждого релиза либо и для того, и для другого.
* **_Отслеживаемость_**. Возможность отслеживать каждое изменение, внесенное в программное обеспечение, и связывать его с ПО для управления проектами и отслеживания ошибок. История с комментариями во время чтения кода помогает понять, что этот код делает и почему действие реализовано именно таким образом. Благодаря этому разработчики могут вносить корректные и совместимые изменения в соответствии с долгосрочным планом разработки системы.

# **Подготовка к работе**

1. Скачать и установить VS Code *https://code.visualstudio.com/docs/?dv=win*

2. Скачать и установить Git *https://git-scm.com/download/win*

3. Проверить, работает ли git с помощью команды
   git --version
4. Добавить имя и email пользователя с помощью команд

   git config --global user.email "email@mail.com"

   git config --global user.name "User Name"

## **Команды**

**git init**

Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем.

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду git add несколько раз, указав индексируемые файлы, а затем выполнив git commit:

**git add**

Команда git add добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

**git status**

Команда git status показывает
состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

**git commit**

Команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

**git log**

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда git log.

**git checkout**

После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду git checkout. Команда git checkout — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика.

**git checkout master**

переключение на ветку master в последний коммит

**git diff**

Показывает различия между проиндексированной и последней зафиксированной версиями файлов

**git diff [первая ветка]...[вторая ветка]**

Показывает разницу между содержанием коммитов двух ветокgit

**git show [коммит]**

Выводит информацию и показывает изменения в выбранном коммите

**git branch**

Список именованных веток коммитов с указанием выбранной ветки

**git branch [имя ветки]**

Создаёт новую ветку

**git merge [имя ветки]**

Вносит изменения указанной ветки в текущую ветку

**git branch -d [имя ветки]**

Удаляет выбранную ветку

**git commit --amend**

Команда *git commit --amend* — это удобный способ изменить последний коммит. Она позволяет объединить проиндексированные изменения с предыдущим коммитом без создания нового коммита. Ее можно использовать для редактирования комментария к предыдущему коммиту без изменения состояния кода в нем. Но такое изменение не только редактирует последний коммит, но и полностью его заменяет. То есть измененный коммит станет новой сущностью с отдельной ссылкой. Для Git он будет выглядеть как новый коммит, который отмечен звездочкой (*) на схеме внизу.

![last_commit.svg](ameded_last_commit.svg)

Например, команда *git commit --amend -m "an updated commit message"* позволяет изменить комментарий последего коммита на *"an updated commit message"*.

**git remote**

Команда _git remote_ позволяет создавать, просматривать и удалять подключения к другим репозиториям. Удаленные подключения скорее похожи на закладки, чем на прямые ссылки на другие репозитории. Они служат удобными именами, с помощью которых можно сослаться на не очень удобный URL-адрес, а не предоставляют доступ к другому репозиторию в режиме реального времени.

Например, на следующем рисунке изображены два удаленных подключения из вашего репозитория к центральному репозиторию и репозиторию другого разработчика. Вместо того, чтобы ссылаться на них по их полным URL-адресам, вы можете передавать командам Git только ярлыки origin и john.

![remote_picture](remote.svg)

Например, команды _git remote_ и _git remote -v_ показывают список ваших удаленных подключений к другим репозиториям, причем последняя включает URL-адрес каждого подключения.

Следующие команды позволяют управлять подключениями к другим репозиториям:

* _git remote add [name] [url]_ - cоздает новое подключение к удаленному репозиторию. После добавления удаленного репозитория имя _[name]_ можно использовать в качестве удобного ярлыка для адреса _[url]_ в других командах Git.
* _git remote rm [name]_ - удаляет подключение к удаленному репозиторию с именем _[name]_.
* _git remote rename [old-name] [new-name]_ - переименовывает удаленное подключение с имени [old-name] на [new-name].

**git push**

Команда _git push_ используется для выгрузки содержимого локального репозитория в удаленный репозиторий. Она позволяет передать коммиты из локального репозитория в удаленный. Эта команда симметрична команде _git fetch_: при извлечении с помощью _fetch_ коммиты импортируются в локальные ветки, а при публикации с помощью _push_ коммиты экспортируются в удаленные ветки. Настроить удаленные ветки можно с помощью команды _git remote_. Команда _push_ может перезаписать изменения, поэтому при ее использовании следует соблюдать осторожность.

**git fetch**

Команда _git fetch_ загружает коммиты, файлы и ссылки из удаленного репозитория в ваш локальный репозиторий. Извлеките данные с помощью команды fetch, если хотите увидеть, над чем работают остальные. При этом не выполняетсятся слияние изменений с вашим репозиторием. Извлеченное содержимое в Git остается изолированным от имеющихся локальных данных и совершенно не влияет на локальную разработку. Чтобы переключиться на извлеченное содержимое, нужно отдельно запустить команду git checkout. Таким образом, применение команды fetch позволяет безопасно просмотреть коммиты, перед тем как интегрировать их в локальный репозиторий.

**git pull**

Команда _git pull_ используется для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым. Слияние удаленных вышестоящих изменений в локальный репозиторий — это обычная задача рабочего процесса, возникающая при совместной работе на основе системы Git. Команда _git pull_ на самом деле представляет собой комбинацию двух других команд: _git fetch_ и _git merge_. На первом этапе _git pull_ выполняется команда _git fetch_, ограниченная локальной веткой, на которую указывает _HEAD_. Сразу после загрузки содержимого команда _git pull_ выполняет слияние. Для слитого содержимого создается новый коммит, а указатель _HEAD_ обновляется и начинает указывать на этот новый коммит.
